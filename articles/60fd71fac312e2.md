---
title: "【Discord】Enterで送信されないようにするキーバインド"
emoji: "⌨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["windows", "discord", "autohotkey"]
published: true
---

# 完成コード
https://github.com/clumsy-ug/discord_ahk_keybind/blob/main/DiscordKeybind.ahk

# 環境
- Windows 11 Home
- 標準搭載のMicrosoft IME
- Discordアプリ

# 背景(前提)
Discordは以下のようなキーバインドがされています。

- Enterで送信またはIMEの補完の確定
- Shift + Enterで改行

これで個人的に困ることは以下です。

- 半角英数字モードで入力しているとき、Enterを押したら送信されてしまう
- ひらがなモードで入力しているとき、IMEの補完の確定でEnterを押そうとして誤って2連続でEnterを押してしまった場合、送信されてしまう
- 改行するたびにわざわざキーを2つ(Shift + Enter)押す必要がある

「誤って送信してしまったので編集するはめになり、編集すると文の最後に `(edited)` という邪魔なものがついてしまう」という事象はDiscord界で頻発しているのでは？と思っています。これがストレスでした。

また、1つの文章につき送信は必ず1回しか行いません。しかし改行は複数回行われるということはよくあります。
なので改行はEnterという1つのキーだけで機能させたいという思いがありました。

簡単に言えば、**Slackと全く同じようにしたかった**という感じです。

実はDiscordアプリ側でキーバインドの設定をすることはできますが、なぜか改行・送信に関するものは用意されていないので、やはりアプリ側でカスタマイズすることは不可能です。
（なぜ用意しないのか、Discord側の思想(理由)が純粋に気になる）

この議題に関する記事はいくつかありますが、どれも上述の理想をかなえてくれるものではありませんでした。そもそもMacでしか動かなかったり、機能が物足りなかったりするものしかありませんでした。

なので自分で頑張って作ってみました。完璧に理想をかなえることができたので詳細を書いていきます。

# どんな感じで進めていったか
どんな思考プロセスで進めて、どんなことに苦戦したのかをつらつら書いていきます。

※記事を引用してそれに対して「こんな問題がありました」という形式にしていますが、決してその記事に問題があるという意図ではありません。すべてとても意義のある記事ですし、事実すごく助かりました。あくまで「私の今回の理想をかなえるためにはこの記事では不十分だった」という意味で「問題」と書いています。

---

まず、Karabiner-Elementsというソフトウェアで同じことをしている方がいることを知りました。
https://zenn.dev/mh/articles/ccd9fd185a66d4
https://zenn.dev/shuto2828/articles/63edac4f20f057

しかしこれはmacOS専用なのでWindowsでは使えませんでした😢
> A powerful and stable keyboard customizer for macOS.

https://karabiner-elements.pqrs.org/

---

そこで次に、私と同じWindows 11 Homeの環境を使用しているこちらの記事を見ました。
https://note.com/teruyoshikun/n/n0b7e1b45529d

これでAutoHotkeyというソフトウェア(スクリプト言語)の存在を知りました。
これはWindows専用！期待できます。
> The ultimate automation scripting language for Windows.

https://www.autohotkey.com/

しかし記事を読んだあと疑問・課題が4つ残りました。

1. なぜあえて古い方のv1.1を使うのかわからない
    - できれば新しいバージョン2を使いたい
    ![ahkバージョン](image-3.png)
2. なぜ.ahkではなく.ashという拡張子を使うのか
    - 公式では.ahkを使えと書かれている(v1とv2のドキュメント両方で)
    >  A script is simply a plain text file with the `.ahk` filename extension containing instructions for the program, like a configuration file, but much more powerful. 
  https://www.autohotkey.com/docs/v1/Program.htm
3. このコードだと、補完の確定をしようとEnterを押しても何も起こらない
    - わざわざCtrl + Enterを押さなければ補完確定できない
4. `shell::startup`を打ってもエラーになる（調べたらすぐ解決できたけど）
![エラー写真](image.png)

正直動けば良いので1, 2, 4は重要ではないのですが、3が私にとってはクリティカルでした。

ただキーバインドを設定するなら簡単にできそうなんですが、今回の様にIMEが関わると複雑になります。

そこで調べるうちに凄く良さげなものを見つけました。
https://w.atwiki.jp/eamat/pages/17.html

> AutoHotkey上で日本語入力の制御を可能にするための関数群

ドンピシャだ！と思いました。事実助かりました。
しかし1つだけ問題がありました。

**IME_GetConverting関数が機能しない**という問題です。
(IME_GET関数は機能する)

名前からわかるように「現在変換中かどうか(入力中かどうか)」を調べることのできる関数です。

変換中は1か2が返ってくるはずなのですが、どんな時でもなぜか0しか返ってこないのです。

これが使えれば、コードは以下のように書くだけで完成していたはずです。
```autohotkey:discord_keybind.ahk
; Enterが押された時
Enter::
{
    converting := IME_GetConverting()
    if (converting > 0) {  ; もし入力中(補完候補がでている状態)だったら
        SendInput "{Enter}"  ; Enterで補完確定
    } else {  ; もし入力中ではない状態だったら
        SendInput "+{Enter}"  ; Shift + Enter で改行
    }
    return
}

; Ctrl + Enter が押された場合
^Enter::
{
    SendInput "{Enter}"  ; Enterで送信または補完確定
    return
}
```

自分の環境で試してみた結果、主要な関数の結果はこうなりました。

- **IME_GET**

ひらがなモードなら1、半角英数字モードなら0がちゃんと返ってくる

- **IME_GetConvMode**

9しか返ってこない

- **IME_GetSentenceMode**

8しか返ってこない

- **IME_GetConverting**

0しか返ってこない

---

ひらがなモードで入力中かどうか(補完が出ているかどうか)の状態が欲しかったので、何としてもIME_GetConverting関数は使いたかったのですが、諦めることにしました。

自分のMicrosoft IMEは新しいバージョンになっていたので、以前のバージョンにあえて戻してみたのですが、それでもIME_GetConvertingは0しか返してくれませんでした。
（ここをONにした）
![IMEバージョンの写真](image-1.png)

つまり問題の核は、「関数が新しいMS IMEには対応してない」ということなのですが、結局対応させる方法がわかりませんでした。

---

次に考えたのは、**Escapeキー**を使用する方法です。

Escapeキーを実行すればひらがなモードで入力中の文字は消えますよね。

そこから、なんとなく以下のようにやればいけるのではないかと考えました。

```mermaid
flowchart TD
    subgraph GlobalState[入力中の文字数を保持]
        CountVar[count]
    end

    START(( )) -->|Enter押下| B["全文をコピー
    (allText変数に保持)
    1.　Ctrl+A
    2.　Ctrl+C"]
    CountVar -.->|参照| C
    B --> C["入力中文字を選択＆コピー
    1.　Shift+← (count回)
    2.　Ctrl+C"]
    C --> D["Escapeキー実行"]
    D --> E["再度全文をコピー
    (newAllText変数に保持)
    1.　Ctrl+A
    2.　Ctrl+C"]
    E --> F{"allTextと
    newAllTextが
    一致する？"}
    F -->|Yes=入力中でない| G["Shift+Enter
    で改行"]
    F -->|No=入力中| H["Enterで
    補完を確定"]

    style GlobalState fill:#e0f0ff,stroke:#333
    style CountVar fill:#f9f,stroke:#333
    style F fill:#ff9,stroke:#333
```

ですが、結果全然ダメでした。

なぜなら、そもそも補完を確定してからでないとShift + ←で入力中の文字をコピーできないからです。

しかしその補完を補完を確定するためにEnterを押すべきかどうかはわからないですよね。
補完は出ておらず(=補完確定済み)、Shift + Enterで改行したいだけなのかもしれません。

なのでやはり、**入力中かどうか(補完が出ているかどうか)という状態を取らないといけない**という根本課題は残り続けたままです。

---

あとは、「クリックするだけでも補完確定できるぞ！」ということに気付いたのでクリック実行関係を試しましたが、これも結局同じ結末でした。

なぜなら、**クリックして確実に補完確定後の状態にしたとしても、その後改行をしたいのかどうかはわからないから**です。

やはり入力中かどうかをなんとかして判定しないとならないか・・・という結果でした。

---

そしていろいろ考えていたら、**入力中の文字数を数えるcount変数をうまく使えば理想を実現できる**ことにやっと気付きました。

先程のフローチャート図でも出てきたやつです。

この変数は、Enterが押される度に0に初期化します。そして文字を入力するたびに+1します。

それによって以下の様にするだけで良いことになります。

- Enterが押されて...
    - 英数字モードなら問答無用でShift + Enterの改行を実行して終了してOK
    - countが0より大きいなら...    
        - Enterで補完確定
    - countが0なら...
        - Shift + Enterで改行

```mermaid
flowchart TD
    A[Enter押下] --> B{英数字モード}
    B -->|Yes| C[Shift + Enterで改行]
    B -->|No| D{countが0より大きい}
    D -->|Yes| E[Enterで補完確定]
    D -->|No| F[Shift + Enterで改行]
    C --> G["countを0に初期化"]
    E --> G
    F --> G
```

実際のコード
```autohotkey:DiscordKeybind.ahk
; Enter が押された場合
Enter::
{
    ; 確認用
    ; ToolTip("countは: " . count)
    ; SetTimer () => ToolTip(), -2000

    global count
    imeMode := IME_GET()

    if (imeMode) {
        if (count == 0) {
            SendInput "+{Enter}"
        } else {
            SendInput "{Enter}"
            count := 0
        }
    } else {
        SendInput "+{Enter}"
        count := 0
    }

    return
}


; Ctrl + Enter が押された場合
^Enter::
{
    SendInput "{Enter}"
    return
}
```

これで試してみたらちゃんと動きました。やっとです。

ちなみに、AutoHotkeyのバージョン2に合わせて先程の関数郡を更新している方がおり、IME_GET関数はその中から使わせていただきました。私もバージョン2のAutoHotkeyで書くことにしたので、助かりました。
https://qiita.com/kenichiro_ayaki/items/d55005df2787da725c6f
https://github.com/k-ayaki/IMEv2.ahk/blob/master/IMEv2.ahk

...ただ！実はまだ**英語を打って最後に日本語モードに変えてからEnterを押すと送信されてしまう**という問題が残っています。

なぜなら、

`count > 0` かつ 日本語モード
↓
「補完が出ているからEnterで補完確定すべきだ」と判断されてしまう

という流れになるからです。

これに対しては、`~sc029::`で半角/全角キーを取得できることがわかったのでそのスコープ内にcountを0に初期化する処理を書いて解決しました。
```autohotkey:DiscordKeybind.ahk
; 半角/全角 が押された場合（「英語->日本語」ならcountを0にする）
~sc029::
{
    global count
    ; 押された瞬間のモードが取得できるので、「英語->日本語」の変更では「英語」が取得される
    imeMode := IME_GET()

    if (!imeMode) {
        count := 0
    }

    ; 確認用
    ; ToolTip("countは" . count . " / " . "imeModeは" . imeMode)
    ; SetTimer () => ToolTip(), -2000

    return
}
```

---

ちなみに、countの処理はこのように書いています。
```autohotkey:DiscordKeybind.ahk
; キーが押された回数
global count := 0

; ほぼ全てのキーが押された際の処理(半角/全角キー などは不要なので除く)
~*a::
~*b::
~*c::
~*d::
~*e::
~*f::
~*g::
~*h::
~*i::
~*j::
~*k::
~*l::
~*m::
~*n::
~*o::
~*p::
~*q::
~*r::
~*s::
~*t::
~*u::
~*v::
~*w::
~*x::
~*y::
~*z::
~*1::
~*2::
~*3::
~*4::
~*5::
~*6::
~*7::
~*8::
~*9::
~*0::
~*Space::
~*,::
~*.::
~*/::
~*;::
~*[::
~*]::
~*-::
~*=::
{
    global count
    count++
    
    ; 確認用
    ; ToolTip("countは: " . count)  ; カウントをツールチップで表示
    ; SetTimer () => ToolTip(), -2000  ; 2秒後にツールチップを消す

    return
}
```

ということでやっと完成です。

完璧にSlackと同じ挙動がDiscordで確認できました🥳

# 使い方
ただ、PCの電源を入れるたびに毎回.ahkファイルをダブルクリックして実行するのは面倒です。

そのため、この.ahkファイルをスタートアップとして登録することで、PC起動時に自動的に起動するようにします。

方法は以下です。

1. Windows + R
2. `shell:common startup`と入力してEnter
3. 開いたフォルダ内に.ahkファイルを配置

これで完了です。

# 最後に
この記事と同じような内容の記事は見当たらなかったので自力で考える必要がありましたが、実装できて良かったです。

Windowsアプリ(ソフトウェア)として作成してそれを配布できたら楽だなぁと思っているのでいつかやりたいです。

また、まだ試してませんが、
```autohotkey:DiscordKeybind.ahk
#HotIf WinActive("ahk_exe Discord.exe")
```
という部分を他のファイル名に変えれば、DiscordだけでなくGPTやClaudeなどの生成AIでも同じキーバインドを適用することができると思います。
