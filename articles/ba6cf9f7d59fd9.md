---
title: "ReactのuseStateの内部構造を理解する"
emoji: "🎞️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "usestate"]
published: false
---

雰囲気で使っていたuseStateの仕組みを理解するべくまとめてみました。

## 処理の流れメモ
set関数が呼ばれる
->「stateの更新」と「再レンダリング」がキューイングされる
->イベントハンドラなどのメインの処理が終わる
->

- 「レンダリング」の示す具体的な処理内容は以下2点
1. コンポーネントの呼び出し
2. 呼び出されたコンポーネントと前回レンダリング時のコンポーネントの差分計算

->で、差分がなかった場合は
差分があった場合は


## 疑問メモ
- react fiberとは？
https://zenn.dev/porokyu32/articles/960d9d6e45533b
- キューのような動作をする(厳密にはキューではないのか？)、JSの概念としてマイクロタスクとマクロタスクがある
https://zenn.dev/ktmouk/articles/68fefedb5fcbdc
これらを理解しないとこの公式ページのチャレンジ問題のsetTimeout終了前に画面更新が行われる理由が理解できないだろう
https://ja.react.dev/learn/queueing-a-series-of-state-updates#challenges
- 再レンダリングの後の仮想DOM作成は、再レンダリングという概念に含まれる？

## 学び
- set->普通の処理(イベントハンドラやconsole.logなど)->state変更->再レンダリング->コンポーネント呼び出し->差分計算->仮想DOMを実DOMにコミット->ペイント(ここでUIがちゃんと変わってる)
- レンダリングの直前のstate更新のバッチ処理について
https://ja.react.dev/learn/queueing-a-series-of-state-updates
- あーわかったかも。set関数が呼び出された時はset関数が呼び出されるだけであって、set関数の引数を呼び出す(=更新)というのが即時実行されずに予約されるんだ。で、バッチ処理の際には、set関数が呼び出されるのではなく、set関数の引数(=処理やデータ)が呼び出されるのか！
> イベントハンドラ内のすべてのコードが実行されるまで、React は state の更新処理を待機します
https://ja.react.dev/learn/queueing-a-series-of-state-updates

- set関数の引数の(n => n + 1)とか自体を更新用関数と言うらしい

## 前提

- 更新と変更は同じ意味とする？

## Q1. なぜuseStateでは「state更新」「再レンダリング」を即実行せずにわざわざ予約するの？

公式では5点紹介されていました。
https://ja.react.dev/learn/updating-objects-in-state

**A1. 効率化・最適化のため。**

複数のset関数ごとに毎回再レンダリングを行うとレンダリング回数が多くなってしまうのは当然予想できる。つまり無駄な再レンダリングが増える。

なのでそれに対処するために、再レンダリング対象(=stateの変更)をバッチ処理化することで対処している。
→後でまとめて**1回の**再レンダリングで済ますことができる。

この「後でまとめて」やるよ、というのが予約である。

**A1-b. 途中でstateが変わったらややこしくなるから**
何度も変えていた場合、stateがどこでどう変わっているのかという処理の流れがわからなくなる。
そうではなく、レンダリングされた瞬間のstateをコード内のすべての場所で共有する。それによってstateを参照している場所でのstateの値は絶対に同じになるので、出力結果が予想しやすくなる。つまり意図しない変な画面にはなりにくくなる、ということ。

## Q2. 予約って何？

**A2. React内部のキューに突っ込むこと、即ち「キューイング」**

キューという言葉から分かるように、実行される予定の処理たちが「列を作って待っている」というのが「予約」のイメージ。

予約が入るたびに、その予約をとりあえずどんどんキューに突っ込んでいく。つまり即時実行はしない。それがuseStateの哲学。

## Q3. 「state更新」「state変更」「再レンダリング」が予約されるのはいつ？

## Q4. 予約された「state更新」「state変更」「再レンダリング」が実際に実行されるのはいつ？

Q.3とQ.4にまとめて答える。

まず、Reactアプリでの画面更新のライフサイクル、すなわちset関数が呼ばれてからブラウザの画面が変更されるまでの流れは以下の通りである。
（初回レンダリングの説明は割愛し、あくまで再レンダリング、即ち2回目以降のレンダリングに焦点をあてて説明する）

1. set関数が呼び出される
    - Reactは新しいstateを内部的にキューに入れる（キューイング）。「state更新」「再レンダリング」の両方を予約する。

2. Reactは、現在の実行コンテキスト（例：イベントハンドラ）が完了するまで待つ。

3. その後、キューに入れられた全てのstate更新を処理する。この時点で、コンポーネントのstateが実際に更新される。

4. すべてのstateが更新された後、更新されたstateが変更もされていたら予約されていた再レンダリングを実行する。更新されただけで変更はされていないなら予約されていた再レンダリングはスキップされる。

5. 再レンダリング実行後、変更後のstateを反映した仮想DOMが生成される。（変更されていなかったら仮想DOMすら生成されずに終了？その場合は次のプロセスに疑問が残る）

6. 仮想DOMと実際のDOMを比較し（差分検出）、必要な変更のみ実際のDOMに適用する（=コミット）。
ー＞仮想DOM作成されてる時点でstateに変更があったということになるので差分があるのは当たり前じゃね？


set関数が呼び出される(=state更新)
->state更新が実行。それを検知したReactは、「そのstateが変更されてるかどうかあとで確認するわ。で、もし変更されてたらそのstateと関係のあるコンポーネントを後でレンダリングするわ。もし変更されてなかったらレンダリングはしないで良いからスキップな。」


**A3 & A4. 以上を踏まえると以下の様に回答することができる**
- state更新の予約

「state更新」は「set関数が呼ばれる」と同義なので、そもそも予約という概念は無い。

- state更新の実行

set関数が呼ばれた時（1番）

- state変更の予約

set関数が呼ばれた時（1番）

- state変更の実行

〇番で実行される。

- 再レンダリングの予約

1番で予約される。

- 再レンダリングの実行

〇番で実行される。

## Q5. じゃあstate更新後の(最新の)stateを参照したい場合はどうすれば良いの？
これまでの説明を踏まえればわかるように、set関数を呼び出した直後に新しいstateを参照しようとしても、更新前の古い値しか得られない。例えば、以下の様に書いても、`console.log(state)`の出力結果は0である。

```jsx
const [state, setState] = useState(0);

setState(state + 1); // ここで即時更新されている訳ではないので...
console.log(state); // この結果は1ではなくまだ0のまま
```

つまり、set関数は非同期処理なのである。
しかし非同期処理だからと言ってasync/awaitなどを使える訳でもない。
→ではどうやって最新の(変更後の)stateを取得するのか？という疑問。

公式のページに、ちゃんと答えが書かれている
> しかし、再レンダー前に最新の state を読み取りたい場合はどうでしょうか？ state 更新用関数を使うことができます。

https://ja.react.dev/learn/state-as-a-snapshot


**A5. `useEffect`を使用する。**？

他にも`useLayoutEffect`を使用するか、Reactの`flushSync`関数を使用するなどの方法はあるらしいが、今回は割愛。

useEffectの依存配列に、変更を検知したいstateを入れれば、それが変更された後にuseEffect内の処理が実行される。

例えば先ほどのstateの例で言えば、以下の様に書くことができる。

```jsx
const [state, setState] = useState(0);
setState(1);

useEffect(() => {
    console.log(state); // ちゃんと1が出力される
}, [state]);
```
